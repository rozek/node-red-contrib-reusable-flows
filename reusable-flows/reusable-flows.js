"use strict";module.exports=function(e){var n,t=0,r=Object.create(null);e.nodes.registerType("reusable-in",(function(n){e.nodes.createNode(this,n);var t=this;t.name=n.name,t.scope=n.scope,t._mayBeUsed=!1,t._DesignError=void 0,t.on("input",(function(e,n,r){if(!t._mayBeUsed)return(null==r?t.error:r)("reusable-in: must not be used due to design errors");(n=n||function(){t.send.apply(t,arguments)})(e),r&&r()}));var r="reusable:"+n.id;function o(e){t.receive(e)}e.events.on(r,o);var s="tweak-"+n.id;function u(e){var n=e[0],r=e[1];t[n]=r,"_DesignError"===n&&(null==r?t.status({}):(t._mayBeUsed=!1,t.status({fill:"red",shape:"dot",text:r})))}e.events.on(s,u),t.on("close",(function(){e.events.removeListener(r,o),e.events.removeListener(s,u)}))})),e.nodes.registerType("reusable-out",(function(t){e.nodes.createNode(this,t);var o=this;o.position=t.position,o._Index=void 0,o._mayBeUsed=!1,o._DesignError=void 0,o.on("input",(function(t,s,u){if(!o._mayBeUsed)return(null==u?o.error:u)("reusable-out: must not be used due to design errors");try{var i=t._reusableFlows,a=i.Stack.pop();if(null==a)throw"reusable-out: no invocation to return to found";var l=r[a];if(delete r[a],"string"!=typeof l)throw"reusable-out: broken invocation (did you try to return several times from the same invocation?)";if(null==n[l])throw'reusable-out: no "reusable" node to return to found';i.Mode="return",i.Index=o._Index,e.events.emit("reusable:"+l,t),u&&u()}catch(e){return(null==u?o.error:u)("string"==typeof e?e:'reusable-out: broken "msg" (broken or missing internals)')}}));var s="tweak-"+t.id;function u(e){var n=e[0],t=e[1];o[n]=t,"_DesignError"===n&&(null==t?o.status({}):(o._mayBeUsed=!1,o.status({fill:"red",shape:"dot",text:t})))}e.events.on(s,u),o.on("close",(function(){e.events.removeListener(s,u)}))})),e.nodes.registerType("reusable",(function(n){e.nodes.createNode(this,n);var o=this;o.target=n.target,o.outputs=n.outputs,o._TargetNode=void 0,o._mayBeUsed=!1,o._DesignError=void 0,o.on("input",(function(s,u,i){if(!o._mayBeUsed)return(null==i?o.error:i)("reusable: must not be used due to design errors");u=u||function(){o.send.apply(o,arguments)};var a=s._reusableFlows;switch(null==a&&(a=s._reusableFlows={Stack:[]}),a.Mode){case void 0:r[t+=1]=n.id,a.Stack.push(t),e.events.emit("reusable:"+o._TargetNode.id,s);break;case"return":var l=a.Index;switch(delete a.Mode,delete a.Index,!0){case 1===o.outputs:u(s);break;case 0===l:u([s]);break;case"number"!=typeof l:case Math.round(l)!==l:case l<0:case l>=o.outputs:return(null==i?o.error:i)('reusable: broken "msg" (invalid "Index")');default:var d=new Array(o.outputs);d[l]=s,u(d)}i&&i();break;default:return(null==i?o.error:i)('reusable: broken "msg" (missing "Mode")')}}));var s="reusable:"+n.id;function u(e){o.receive(e)}e.events.on(s,u);var i="tweak-"+n.id;function a(e){var n=e[0],t=e[1];o[n]=t,"_DesignError"===n&&(null==t?o.status({}):(o._mayBeUsed=!1,o.status({fill:"red",shape:"dot",text:t})))}e.events.on(i,a),o.on("close",(function(){e.events.removeListener(s,u),e.events.removeListener(i,a)}))})),e.events.on("flows:started",(function(){n=Object.create(null),e.nodes.eachNode((function(e){n[e.id]=e}));var t=Object.create(null);function r(n,t,r){n[t]=r,"_DesignError"===t&&null!=r&&(n._mayBeUsed=!1),e.events.emit("tweak-"+n.id,[t,r])}function o(e,n){r(e,"_DesignError",n)}function s(e){r(e,"_DesignError",void 0)}function u(n,t){n=n.toLowerCase();var r=[];return e.nodes.eachNode((function(e){"reusable-in"===e.type&&l[e.z]===t&&(e.name||"").trim().toLowerCase()===n&&r.push(e)})),r}e.nodes.eachNode((function(e){(e.wires||[]).flat().forEach((function(n){n in t?t[n].push(e.id):t[n]=[e.id]}))}));var i,a=[],l=Object.create(null);e.nodes.eachNode((function(e){"tab"===e.type&&(l[e.id]=e,a.push(e))}));try{(i=[],e.nodes.eachNode((function(e){"reusable-out"===e.type&&i.push(e)})),i).forEach((function(e){if(null==l[e.z])return o(e,"do not end reusable flows within subflows");var u=function(e){var r=Object.create(null);r[e.id]=e,function e(o){(t[o.id]||[]).forEach((function(t){if(!(t in r)){var o=n[t];r[t]=o,e(o)}}))}(e);var o=[];for(var s in delete r[e.id],r)o.push(r[s]);return o}(e).filter((function(e){return"reusable-in"===e.type}));if(0===u.length)return o(e,'no connected "reusable-in" node');if(u.length>1)return o(e,'multiple connected "reusable-in" nodes');var i=parseInt(e.position,10)-1;if(isNaN(i))return o(e,'invalid "position"');r(e,"_Index",i),r(e,"_mayBeUsed",!0),s(e)})),function(){var t;(t=[],e.nodes.eachNode((function(e){"reusable-in"===e.type&&t.push(e)})),t).forEach((function(e){if(null==l[e.z])return o(e,"do not begin reusable flows within subflows");var t=(e.name||"").trim().toLowerCase();if(""===t)return o(e,"no flow name given");if(u(t,l[e.z]).length>1)return o(e,'multiple "reusable-in" nodes with this name');var i=function(e){var t=Object.create(null);t[e.id]=e,function e(r){r.wires.flat().forEach((function(r){if(!(r in t)){var o=n[r];t[r]=o,e(o)}}))}(e);var r=[];for(var o in delete t[e.id],t)r.push(t[o]);return r}(e).filter((function(e){return"reusable-out"===e.type}));if(0===i.length)return o(e,'no connected "reusable-out" node');if(s(e),1===i.length){var a=i[0];a._Index>=1&&o(a,"invalid output position"),r(e,"outputs",1)}else{var d=Object.create(null),c=new Array(i.length);i.forEach((function(e){var n=e._Index;if(n>=i.length)return o(e,"invalid output position");if(null!=c[n])return o(c[n],"multiply used output position"),void o(e,"multiply used output position");c[n]=e;var t=(e.name||"").trim().toLowerCase();if(""!==t){if(null!=d[t])return o(c[n],"multiply used output label"),void o(e,"multiply used output label");d[t]=e}})),r(e,"outputs",c.length)}i.forEach((function(e){return r(e,"_mayBeUsed",null==e._DesignError)})),r(e,"_mayBeUsed",null==e._DesignError&&i.reduce((function(e,n){return e&&n._mayBeUsed}),!0)),e._mayBeUsed?s(e):null==e._DesignError&&o(e,'error in "reusable-out" node')}))}(),function(){var n;(n=[],e.nodes.eachNode((function(e){"reusable"===e.type&&n.push(e)})),n).forEach((function(e){if(null==l[e.z])return o(e,"do not invoke reusable flows from within subflows");var n,t,i=(e.target||"").trim().toLowerCase();if(""===i)return o(e,"missing target specification");i.indexOf(":")<0?(n="",t=i):(n=i.replace(/\s*:.*$/,""),t=i.replace(/^[^:]*:\s*/,""));var d=l[e.z];if(""!==n){var c=function(e){e=e.trim().toLowerCase();var n=[];return a.forEach((function(t){t.label.trim().toLowerCase()===e&&n.push(t)})),n}(n);switch(c.length){case 0:return o(e,"no such target workspace");case 1:d=c[0];break;default:return o(e,"multiple target workspaces")}}if(""===t)return o(e,"missing target flow name");var f=u(t,d).filter((function(n){return"global"===n.scope||n.z===e.z}));switch(f.length){case 0:return o(e,"no such target flow");case 1:r(e,"_TargetNode",f[0]);break;default:return o(e,"multiple target flows")}r(e,"_mayBeUsed",e._TargetNode._mayBeUsed),e._mayBeUsed?s(e):o(e,"error in target flow")}))}()}catch(e){console.error(e)}}))};
//# sourceMappingURL=reusable-flows.js.map
