{"version":3,"file":"reusable-flows.js","sources":["../src/reusable-flows.ts"],"sourcesContent":["/**** some basic type definitions for safety ****/\n\n  type NR_Node   = any\n  type NR_id     = string\n  type NR_Config = any\n  type NR_Msg    = {\n    topic?:string, payload:any, script?:string,\n    _reusableFlows:{ Mode?:'return', Stack:NR_id[] }\n  }\n  type NR_send   = (msg:NR_Msg | NR_Msg[] | NR_Msg[][] | null) => void\n  type NR_done   = (err?:any) => void\n\n/**** actual node definition ****/\n\n  export default function (RED:any):void {\n  /**** resuable-in ****/\n\n    function ReusableIn (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let Node:any = this\n      Node.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        send = send || function () { Node.send.apply(Node,arguments) }\n\n        send(msg)\n        if (done) { done() }\n      })\n\n    /**** handle invcations ****/\n\n      const CallEvent = 'reusable:' + config.id\n\n      function CallEventListener (msg:any):void {\n        Node.receive(msg)\n      }\n\n      RED.events.on(CallEvent,CallEventListener)\n\n      Node.on('close', () => {\n        RED.events.removeListener(CallEvent,CallEventListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable-in', ReusableIn)\n\n  /**** resuable-out ****/\n\n    function ReusableOut (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let Node:any = this\n      Node.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        try {\n          let Internals = msg._reusableFlows\n\n          let callingNodeId = Internals.Stack.pop()\n          if (callingNodeId == null) {\n            throw new Error()\n          } else {\n            Internals.Mode = 'return'\n            RED.events.emit('reusable:' + callingNodeId, msg)\n            if (done) { done() }\n          }\n        } catch (Signal) {\n          console.error('broken msg',msg)\n          Node.error('broken msg')\n          Node.status({ fill:'red', shape:'dot', text:'broken msg' })\n\n          if (done) { done() }\n        }\n      })\n    }\n\n    RED.nodes.registerType('reusable-out', ReusableOut)\n\n  /**** reusable - the calling node ****/\n\n    function Reusable (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let FlowToCall:NR_Node | undefined                    // will be set later\n\n    /**** handle calls to the associated flow ****/\n\n      const Node:any = this\n      Node.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        send = send || function () { Node.send.apply(Node,arguments) }\n\n        if (FlowToCall == null) {\n          send(msg)\n          if (done) { done() }\n          return\n        }\n\n        let Internals = msg._reusableFlows\n        if (Internals == null) {\n          Internals = msg._reusableFlows = { Stack:[] }\n        }\n\n        switch (Internals.Mode) {\n          case undefined:                                              // 'call'\n            Internals.Stack.push(config.id)\n            RED.events.emit('reusable:' + FlowToCall.id, msg)\n            break\n          case 'return':                                             // 'return'\n            delete Internals.Mode\n\n            send(msg)\n            if (done) { done() }\n            break\n          default:                                                 // broken msg\n            console.error('broken msg',msg)\n            Node.error('broken msg')\n            Node.status({ fill:'red', shape:'dot', text:'broken msg' })\n\n            send(null)\n            if (done) { done() }\n        }\n      })\n\n    /**** handle returns from the called flow ****/\n\n      const ReturnEvent = 'reusable:' + config.id\n\n      function ReturnEventListener (msg:any):void {\n        Node.receive(msg)\n      }\n\n      RED.events.on(ReturnEvent,ReturnEventListener)\n\n    /**** update \"FlowToCall\" after flow (re-)start ****/\n\n      const FlowToCallEvent = 'reusable:' + config.id + '-FlowToCall'\n\n      function FlowToCallEventListener (Callee:NR_Node | undefined):void {\n        FlowToCall = Callee\n\n        if (FlowToCall == null) {\n          Node.status({ fill:'yellow', shape:'ring', text:'no flow to call' })\n        } else {\n          Node.status({})\n        }\n      }\n\n      RED.events.on(FlowToCallEvent,FlowToCallEventListener)\n\n    /**** clean up on clode ****/\n\n      Node.on('close', () => {\n        RED.events.removeListener(ReturnEvent,ReturnEventListener)\n        RED.events.removeListener(FlowToCallEvent,FlowToCallEventListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable', Reusable)\n\n  /**** mapCallersToCallees ****/\n\n    function mapCallersToCallees ():void {\nconsole.log('\\n\\n\\nmapCallersToCallees')\n      let Workspaces = Object.create(null)\n      let Subflows   = Object.create(null)\n\n      let ReusablesIn = Object.create(null)\n      let Reusables   = Object.create(null)\n\n    /**** ContainerOfNode ****/\n\n      function ContainerOfNode (Node:NR_Node):NR_Node | undefined {\n        if (Node.type === 'tab') {\n          return undefined\n        } else {\n          let Subflow = Subflows[Node.z]\n          if (Subflow == null) {\n            return Workspaces[Node.z]\n          } else {\n            return Subflow\n          }\n        }\n      }\n\n    /**** TabOfNode ****/\n\n      function TabOfNode (Node:NR_Node):NR_Node | undefined {\n        if (Node.type === 'tab') { return Node }\n\n        let foundTab = Workspaces[Node.z]\n        if (foundTab == null) {\n          foundTab = Subflows[Node.z]\n        }\n\n        return (foundTab == null ? undefined : TabOfNode(foundTab))\n      }\n\n    /**** listWorkspaces ****/\n\n      function listWorkspaces ():void {\n        console.log('Workspaces:')\n        for (let Id in Workspaces) {\n          let Workspace = Workspaces[Id]\n          console.log('  ' + Id + ': \"' + Workspace.label + '\"')\n        }\n      }\n\n    /**** listSubflows ****/\n\n      function listSubflows ():void {\n        console.log('Subflows:')\n        for (let Id in Subflows) {\n          let Subflow = Subflows[Id]\n          console.log('  ' + Id + ': \"' + Subflow.label + '\"')\n        }\n      }\n\n    /**** listReusables ****/\n\n      function listReusables ():void {\n        console.log('Reusables:')\n        for (let Id in Reusables) {\n          let Reusable = Reusables[Id]\n          console.log(\n            '  ' + Id + ': \"' + Reusable.name + '\" -> \"' + Reusable.target + '\"'\n          )\n        }\n      }\n\n    /**** listReusablesIn ****/\n\n      function listReusablesIn ():void {\n        console.log('ReusablesIn:')\n        for (let Id in ReusablesIn) {\n          let ReusableIn = ReusablesIn[Id]\n          console.log(\n            '  ' + Id + ': \"' + ReusableIn.name + '\"'\n          )\n        }\n      }\n\n\n\n    /**** collect workspaces, subflows, reusable_ins and reusables ****/\n\n      RED.nodes.eachNode((Node:any) => {\n        switch (Node.type) {\n          case 'tab':     Workspaces[Node.id] = Node; break\n          case 'subflow': Subflows[Node.id]   = Node; break\n\n          case 'reusable-in':\n            ReusablesIn[Node.id] = Node\n            break\n          case 'reusable':\n            Reusables[Node.id] = Node\n            break\n        }\n      })\nlistWorkspaces()\nlistReusablesIn()\nlistReusables()\n\n    /**** construct mappings and inform reusables ****/\n\n      function inform (CallerId:string, Callee:NR_Node):void {\nconsole.log('mapping ',CallerId,'->',Callee == null ? '-' : '\"' + Callee.name + '\"')\n        RED.events.emit('reusable:' + CallerId + '-FlowToCall', Callee)\n      }\n\nouterLoop: for (let CallerId in Reusables) {\n        let Caller = Reusables[CallerId]\n\n        let [CalleeTabName,CalleeName] = (Caller.target || '').toLowerCase().split(':')\n        if (CalleeName == null) {\n          CalleeName = CalleeTabName.trim(); CalleeTabName = ''\n        } else {\n          CalleeTabName = CalleeTabName.trim()\n          CalleeName    = CalleeName.trim()\n        }\n\n        for (let CalleeId in ReusablesIn) {\n          let Callee = ReusablesIn[CalleeId]\n          if ((Callee.name || '').toLowerCase() !== CalleeName) { continue }\n\n          if (CalleeTabName === '') {\n            if (Caller.z === Callee.z) {\n              inform(CallerId,Callee); continue outerLoop\n            }\n          } else {\n            let CalleeTab = TabOfNode(Callee) || {}\n            if (CalleeTabName !== (CalleeTab.label || '').toLowerCase()) { continue }\n\n            if (\n              (Caller.z === Callee.z) ||\n              (Caller.z !== Callee.z) && (Callee.scope === 'global') &&\n                ((ContainerOfNode(Callee) || {}).type !== 'subflow')\n            ) { inform(CallerId,Callee); continue outerLoop }\n          }\n        }\n\n        inform(CallerId,undefined) // no callee found\n      }\nconsole.log('\\n')\n    }\n\n    RED.events.on('flows:started', mapCallersToCallees)\n\n\n  }\n"],"names":["RED","nodes","registerType","config","createNode","this","Node","on","msg","send","done","apply","arguments","CallEvent","id","CallEventListener","receive","events","removeListener","Internals","_reusableFlows","callingNodeId","Stack","pop","Error","Mode","emit","Signal","console","error","status","fill","shape","text","FlowToCall","undefined","push","ReturnEvent","ReturnEventListener","FlowToCallEvent","FlowToCallEventListener","Callee","log","Workspaces","Object","create","Subflows","ReusablesIn","Reusables","ContainerOfNode","type","Subflow","z","TabOfNode","foundTab","inform","CallerId","name","eachNode","Id","Workspace","label","listWorkspaces","ReusableIn_1","listReusablesIn","Reusable_1","target","listReusables","outerLoop","Caller","_a","toLowerCase","split","CalleeTabName","CalleeName","CalleeId","trim","scope"],"mappings":"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"}