{"version":3,"file":"reusable-flows.js","sources":["../src/reusable-flows.ts"],"sourcesContent":["/**** some basic type definitions for safety ****/\n\n  type NR_Node   = any\n  type NR_id     = string\n  type NR_Config = any\n  type NR_Msg    = {\n    topic?:string, payload:any, script?:string,\n    _reusableFlows:{ Mode?:'return', Stack:NR_id[] }\n  }\n  type NR_send   = (msg:NR_Msg | NR_Msg[] | NR_Msg[][] | null) => void\n  type NR_done   = (err?:any) => void\n\n/**** actual node definition ****/\n\n  export default function (RED:any):void {\n  /**** resuable-in ****/\n\n    function ReusableIn (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let Node:any = this\n      Node.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        send = send || function () { Node.send.apply(Node,arguments) }\n\n        send(msg)\n        if (done) { done() }\n      })\n\n    /**** handle invcations ****/\n\n      const CallEvent = 'reusable:' + config.id\n\n      function CallEventListener (msg:any):void {\n        Node.receive(msg)\n      }\n\n      RED.events.on(CallEvent,CallEventListener)\n\n      Node.on('close', () => {\n        RED.events.removeListener(CallEvent,CallEventListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable-in', ReusableIn)\n\n  /**** resuable-out ****/\n\n    function ReusableOut (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let Node:any = this\n      Node.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        try {\n          let Internals = msg._reusableFlows\n\n          let callingNodeId = Internals.Stack.pop()\n          if (callingNodeId == null) {\n            throw 'reusable-out: no reusable to return to found'\n          } else {\n            Internals.Mode = 'return'\n            RED.events.emit('reusable:' + callingNodeId, msg)\n            if (done) { done() }\n          }\n        } catch (Signal) {\n          throw 'reusable-out: broken \"msg\" (broken or missing internals)'\n        }\n      })\n    }\n\n    RED.nodes.registerType('reusable-out', ReusableOut)\n\n  /**** reusable - the calling node ****/\n\n    function Reusable (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let FlowToCall:NR_Node | undefined                    // will be set later\n\n    /**** handle calls to the associated flow ****/\n\n      const Node:any = this\n      Node.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        send = send || function () { Node.send.apply(Node,arguments) }\n\n        if (FlowToCall == null) {\n          throw 'reusable: no flow found that could be called'\n        }\n\n        let Internals = msg._reusableFlows\n        if (Internals == null) {\n          Internals = msg._reusableFlows = { Stack:[] }\n        }\n\n        switch (Internals.Mode) {\n          case undefined:                                              // 'call'\n            Internals.Stack.push(config.id)\n            RED.events.emit('reusable:' + FlowToCall.id, msg)\n            break\n          case 'return':                                             // 'return'\n            delete Internals.Mode\n\n            send(msg)\n            if (done) { done() }\n            break\n          default:                                                 // broken msg\n            throw 'reusable: broken \"msg\" (missing \"Mode\")'\n        }\n      })\n\n    /**** handle returns from the called flow ****/\n\n      const ReturnEvent = 'reusable:' + config.id\n\n      function ReturnEventListener (msg:any):void {\n        Node.receive(msg)\n      }\n\n      RED.events.on(ReturnEvent,ReturnEventListener)\n\n    /**** update \"FlowToCall\" after flow (re-)start ****/\n\n      const FlowToCallEvent = 'reusable:' + config.id + '-FlowToCall'\n\n      function FlowToCallEventListener (Callee:NR_Node | undefined):void {\n        FlowToCall = Callee\n\n        if (FlowToCall == null) {\n          Node.status({ fill:'red', shape:'dot', text:'no flow to call' })\n        } else {\n          Node.status({})\n        }\n      }\n\n      RED.events.on(FlowToCallEvent,FlowToCallEventListener)\n\n    /**** clean up on clode ****/\n\n      Node.on('close', () => {\n        RED.events.removeListener(ReturnEvent,ReturnEventListener)\n        RED.events.removeListener(FlowToCallEvent,FlowToCallEventListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable', Reusable)\n\n  /**** mapCallersToCallees ****/\n\n    function mapCallersToCallees ():void {\n      let Workspaces = Object.create(null)\n      let Subflows   = Object.create(null)\n\n      let ReusablesIn = Object.create(null)\n      let Reusables   = Object.create(null)\n\n    /**** ContainerOfNode ****/\n\n      function ContainerOfNode (Node:NR_Node):NR_Node | undefined {\n        if (Node.type === 'tab') {\n          return undefined\n        } else {\n          let Subflow = Subflows[Node.z]\n          if (Subflow == null) {\n            return Workspaces[Node.z]\n          } else {\n            return Subflow\n          }\n        }\n      }\n\n    /**** TabOfNode ****/\n\n      function TabOfNode (Node:NR_Node):NR_Node | undefined {\n        if (Node.type === 'tab') { return Node }\n\n        let foundTab = Workspaces[Node.z]\n        if (foundTab == null) {\n          foundTab = Subflows[Node.z]\n        }\n\n        return (foundTab == null ? undefined : TabOfNode(foundTab))\n      }\n\n\n\n    /**** collect workspaces, subflows, reusable_ins and reusables ****/\n\n      RED.nodes.eachNode((Node:any) => {\n        switch (Node.type) {\n          case 'tab':     Workspaces[Node.id] = Node; break\n          case 'subflow': Subflows[Node.id]   = Node; break\n\n          case 'reusable-in':\n            ReusablesIn[Node.id] = Node\n            break\n          case 'reusable':\n            Reusables[Node.id] = Node\n            break\n        }\n      })\n\n    /**** construct mappings and inform reusables ****/\n\n      function inform (CallerId:string, Callee:NR_Node):void {\n        RED.events.emit('reusable:' + CallerId + '-FlowToCall', Callee)\n      }\n\n      outerLoop: for (let CallerId in Reusables) {\n        let Caller = Reusables[CallerId]\n\n        let [CalleeTabName,CalleeName] = (Caller.target || '').toLowerCase().split(':')\n        if (CalleeName == null) {\n          CalleeName = CalleeTabName.trim(); CalleeTabName = ''\n        } else {\n          CalleeTabName = CalleeTabName.trim()\n          CalleeName    = CalleeName.trim()\n        }\n\n        for (let CalleeId in ReusablesIn) {\n          let Callee = ReusablesIn[CalleeId]\n          if ((Callee.name || '').toLowerCase() !== CalleeName) { continue }\n\n          if (CalleeTabName === '') {\n            if (Caller.z === Callee.z) {\n              inform(CallerId,Callee); continue outerLoop\n            }\n          } else {\n            let CalleeTab = TabOfNode(Callee) || {}\n            if (CalleeTabName !== (CalleeTab.label || '').toLowerCase()) { continue }\n\n            if (\n              (Caller.z === Callee.z) ||\n              (Caller.z !== Callee.z) && (Callee.scope === 'global') &&\n                ((ContainerOfNode(Callee) || {}).type !== 'subflow')\n            ) { inform(CallerId,Callee); continue outerLoop }\n          }\n        }\n\n        inform(CallerId,undefined) // no callee found\n      }\n    }\n\n    RED.events.on('flows:started', mapCallersToCallees)\n\n\n  }\n"],"names":["RED","nodes","registerType","config","createNode","this","Node","on","msg","send","done","apply","arguments","CallEvent","id","CallEventListener","receive","events","removeListener","Internals","_reusableFlows","callingNodeId","Stack","pop","Mode","emit","Signal","FlowToCall","undefined","push","ReturnEvent","ReturnEventListener","FlowToCallEvent","FlowToCallEventListener","Callee","status","fill","shape","text","Workspaces","Object","create","Subflows","ReusablesIn","Reusables","ContainerOfNode","type","Subflow","z","TabOfNode","foundTab","inform","CallerId","eachNode","outerLoop","Caller","_a","target","toLowerCase","split","CalleeTabName","CalleeName","CalleeId","trim","name","label","scope"],"mappings":"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"}