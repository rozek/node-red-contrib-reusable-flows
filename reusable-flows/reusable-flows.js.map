{"version":3,"file":"reusable-flows.js","sources":["../src/reusable-flows.ts"],"sourcesContent":["/**** some basic type definitions for safety (or for illustration) ****/\n\n  type NR_Node      = any\n  type NR_Workspace = any\n  type NR_Id        = string\n  type NR_Config    = any\n  type NR_Msg = {\n    topic?:string, payload:any, script?:string,\n    _reusableFlows:{ Mode?:'return', Index?:number, Stack:NR_Id[] }\n  }\n  type NR_send   = (msg:NR_Msg | NR_Msg[] | NR_Msg[][] | null) => void\n  type NR_done   = (err?:any) => void\n\n/**** actual node definition ****/\n\n  export default function (RED:any):void {\n  /**** resuable-in ****/\n\n    function ReusableIn (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let thisNode:NR_Node = this\n        thisNode.name  = config.name\n        thisNode.scope = config.scope\n\n        thisNode._mayBeUsed   = false                   // set during validation\n        thisNode._DesignError = undefined\n      thisNode.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        if (! thisNode._mayBeUsed) {\n          return (done == null ? thisNode.error : done)(\n            'reusable-in: must not be used due to design errors'\n          )\n        }\n\n        send = send || function () { thisNode.send.apply(thisNode,arguments) }\n\n        send(msg)\n        if (done) { done() }\n      })\n\n    /**** handle invocations ****/\n\n      const InvocationEvent = 'reusable:' + config.id\n\n      function InvocationEventListener (msg:any):void {\n        thisNode.receive(msg)\n      }\n\n      RED.events.on(InvocationEvent,InvocationEventListener)\n\n    /**** handle \"tweak\" events ****/\n\n      const TweakEvent = 'tweak-' + config.id\n\n      function TweakListener (Tweak:any[]):void {\n        let [ Key,Value ] = Tweak\n        thisNode[Key] = Value\n\n        if (Key === '_DesignError') {\n          if (Value == null) {\n            thisNode.status({})\n          } else {\n            thisNode._mayBeUsed = false\n            thisNode.status({ fill:'red', shape:'dot', text:Value })\n          }\n        }\n      }\n\n      RED.events.on(TweakEvent,TweakListener)\n\n    /**** clean up on close ****/\n\n      thisNode.on('close', () => {\n        RED.events.removeListener(InvocationEvent,InvocationEventListener)\n        RED.events.removeListener(TweakEvent,TweakListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable-in', ReusableIn)\n\n  /**** resuable-out ****/\n\n    function ReusableOut (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let thisNode:NR_Node = this\n        thisNode.position = config.position\n\n        thisNode._Index       = undefined\n        thisNode._mayBeUsed   = false     // set during \"reusable-in\" validation\n        thisNode._DesignError = undefined\n      thisNode.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        if (! thisNode._mayBeUsed) {\n          return (done == null ? thisNode.error : done)(\n            'reusable-out: must not be used due to design errors'\n          )\n        }\n\n        try {\n          let Internals = msg._reusableFlows\n\n          let callingNodeId = Internals.Stack.pop()\n          if (callingNodeId == null) {\n            throw 'reusable-out: no \"reusable\" node to return to found'\n          } else {\n            Internals.Mode  = 'return'\n            Internals.Index = thisNode._Index\n            RED.events.emit('reusable:' + callingNodeId, msg)\n            if (done) { done() }\n          }\n        } catch (Signal) {\n          return (done == null ? thisNode.error : done)(\n            'reusable-out: broken \"msg\" (broken or missing internals)'\n          )\n        }\n      })\n\n    /**** handle \"tweak\" events ****/\n\n      const TweakEvent = 'tweak-' + config.id\n\n      function TweakListener (Tweak:any[]):void {\n        let [ Key,Value ] = Tweak\n        thisNode[Key] = Value\n\n        if (Key === '_DesignError') {\n          if (Value == null) {\n            thisNode.status({})\n          } else {\n            thisNode._mayBeUsed = false\n            thisNode.status({ fill:'red', shape:'dot', text:Value })\n          }\n        }\n      }\n\n      RED.events.on(TweakEvent,TweakListener)\n\n    /**** clean up on close ****/\n\n      thisNode.on('close', () => {\n        RED.events.removeListener(TweakEvent,TweakListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable-out', ReusableOut)\n\n  /**** reusable - the calling node ****/\n\n    function Reusable (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n    /**** handle calls to the associated flow ****/\n\n      const thisNode:NR_Node = this\n        thisNode.target  = config.target\n        thisNode.outputs = config.outputs\n\n        thisNode._TargetNode  = undefined\n        thisNode._mayBeUsed   = false                   // set during validation\n        thisNode._DesignError = undefined\n      thisNode.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        if (! thisNode._mayBeUsed) {\n          return (done == null ? thisNode.error : done)(\n            'reusable: must not be used due to design errors'\n          )\n        }\n\n        send = send || function () { thisNode.send.apply(thisNode,arguments) }\n\n        let Internals = msg._reusableFlows\n        if (Internals == null) {\n          Internals = msg._reusableFlows = { Stack:[] }\n        }\n\n        switch (Internals.Mode) {\n          case undefined:                                              // 'call'\n            Internals.Stack.push(config.id)\n            RED.events.emit('reusable:' + thisNode._TargetNode.id, msg)\n            break\n          case 'return':                                             // 'return'\n            let Index = Internals.Index\n            delete Internals.Mode; delete Internals.Index\n\n            switch (true) {\n              case (thisNode.outputs === 1):\n                send(msg)\n                break\n              case (Index === 0):\n                send([msg])\n                break\n              case (typeof Index !== 'number'):\n// @ts-ignore \"Index\" is now known to be a number\n              case (Math.round(Index) !== Index): // also handles NaN\n// @ts-ignore \"Index\" is now known to be an integer\n              case (Index < 0):\n// @ts-ignore \"Index\" is still known to be an integer\n              case (Index >= thisNode.outputs):\n                return (done == null ? thisNode.error : done)(\n                  'reusable: broken \"msg\" (invalid \"Index\")'\n                )\n              default:\n                let MsgList = new Array(thisNode.outputs)\n// @ts-ignore \"Index\" is known to be an integer\n                  MsgList[Index] = msg\n                send(MsgList)\n            }\n            if (done) { done() }\n            break\n          default:                                                 // broken msg\n            return (done == null ? thisNode.error : done)(\n              'reusable: broken \"msg\" (missing \"Mode\")'\n            )\n        }\n      })\n\n    /**** handle returns from the called flow ****/\n\n      const ReturnEvent = 'reusable:' + config.id\n\n      function ReturnEventListener (msg:any):void {\n        thisNode.receive(msg)\n      }\n\n      RED.events.on(ReturnEvent,ReturnEventListener)\n\n    /**** handle \"tweak\" events ****/\n\n      const TweakEvent = 'tweak-' + config.id\n\n      function TweakListener (Tweak:any[]):void {\n        let [ Key,Value ] = Tweak\n        thisNode[Key] = Value\n\n        if (Key === '_DesignError') {\n          if (Value == null) {\n            thisNode.status({})\n          } else {\n            thisNode._mayBeUsed = false\n            thisNode.status({ fill:'red', shape:'dot', text:Value })\n          }\n        }\n      }\n\n      RED.events.on(TweakEvent,TweakListener)\n\n    /**** clean up on close ****/\n\n      thisNode.on('close', () => {\n        RED.events.removeListener(ReturnEvent,ReturnEventListener)\n        RED.events.removeListener(TweakEvent,TweakListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable', Reusable)\n\n  /**** validateReusableFlows ****/\n\n    function validateReusableFlows () {\n      let NodeSet = Object.create(null)  // collect all nodes for a quick lookup\n      RED.nodes.eachNode((Node:NR_Node) => {\n        NodeSet[Node.id] = Node\n      })\n\n      let UpstreamWiresOfNode = Object.create(null)    // to find upstream nodes\n      RED.nodes.eachNode((Node:NR_Node) => {\n        let DownstreamWires = (Node.wires || []).flat()\n        DownstreamWires.forEach((DownstreamNodeId:NR_Id) => {\n          if (DownstreamNodeId in UpstreamWiresOfNode) {\n            UpstreamWiresOfNode[DownstreamNodeId].push(Node.id)\n          } else {\n            UpstreamWiresOfNode[DownstreamNodeId] = [Node.id]\n          }\n        })\n      })\n\n    /**** tweak ****/\n\n      function tweak (Node:NR_Node, Key:string, Value:any):void {\n        Node[Key] = Value\n        if ((Key === '_DesignError') && (Value != null)) {\n          Node._mayBeUsed = false\n        }\n\n        RED.events.emit('tweak-' + Node.id, [Key,Value])\n      }\n\n    /**** setDesignErrorOfNode ****/\n\n      function setDesignErrorOfNode (Node:NR_Node, DesignError:string):void {\n        tweak(Node, '_DesignError',DesignError)\n      }\n\n    /**** clearDesignErrorOfNode ****/\n\n      function clearDesignErrorOfNode (Node:NR_Node):void {\n        tweak(Node, '_DesignError',undefined)\n      }\n\n  /**** allUpstreamNodesOf - still to be implemented ****/\n\n    function allUpstreamNodesOf (Node:NR_Node):NR_Node[] {\n      let connectedNodeSet = Object.create(null)\n        connectedNodeSet[Node.id] = Node\n\n        function registerUpstreamNodesOf (Node:NR_Node):void {\n          let UpstreamWires = UpstreamWiresOfNode[Node.id] || []\n          UpstreamWires.forEach((connectedNodeId:NR_Id) => {\n            if (! (connectedNodeId in connectedNodeSet)) {\n              let connectedNode = NodeSet[connectedNodeId]\n              connectedNodeSet[connectedNodeId] = connectedNode\n              registerUpstreamNodesOf(connectedNode)\n            }\n          })\n        }\n        registerUpstreamNodesOf(Node)\n      let Result = []\n        delete connectedNodeSet[Node.id]\n        for (let NodeId in connectedNodeSet) {\n          Result.push(connectedNodeSet[NodeId])\n        }\n      return Result\n    }\n\n  /**** allDownstreamNodesOf ****/\n\n    function allDownstreamNodesOf (Node:NR_Node):NR_Node[] {\n      let connectedNodeSet = Object.create(null)\n        connectedNodeSet[Node.id] = Node\n\n        function registerDownstreamNodesOf (Node:NR_Node):void {\n          let DownstreamWires = Node.wires.flat()\n          DownstreamWires.forEach((connectedNodeId:NR_Id) => {\n            if (! (connectedNodeId in connectedNodeSet)) {\n              let connectedNode = NodeSet[connectedNodeId]\n              connectedNodeSet[connectedNodeId] = connectedNode\n              registerDownstreamNodesOf(connectedNode)\n            }\n          })\n        }\n        registerDownstreamNodesOf(Node)\n      let Result = []\n        delete connectedNodeSet[Node.id]\n        for (let NodeId in connectedNodeSet) {\n          Result.push(connectedNodeSet[NodeId])\n        }\n      return Result\n    }\n\n    /**** existingOutNodes ****/\n\n      function existingOutNodes ():NR_Node[] {\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (Node.type === 'reusable-out') { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** validateAllReusableOutNodes ****/\n\n      function validateAllReusableOutNodes () {\n        let OutNodes:NR_Node[] = existingOutNodes()\n        OutNodes.forEach((OutNode) => {\n          if (WorkspaceWithId[OutNode.z] == null) return setDesignErrorOfNode(\n            OutNode, 'do not end reusable flows within subflows'\n          )\n\n          let wiredInNodes = allUpstreamNodesOf(OutNode).filter(\n            (Node:NR_Node) => (Node.type === 'reusable-in')\n          )\n          if (wiredInNodes.length === 0) return setDesignErrorOfNode(\n            OutNode, 'no connected \"reusable-in\" node'\n          )\n\n          if (wiredInNodes.length > 1) return setDesignErrorOfNode(\n            OutNode, 'multiple connected \"reusable-in\" nodes'\n          )\n\n          let Index = parseInt(OutNode.position,10) - 1               // 0-based\n          if (isNaN(Index)) {\n            return setDesignErrorOfNode(OutNode,'invalid \"position\"')\n          } else {\n            tweak(OutNode, '_Index',Index)\n          }\n\n          tweak(OutNode, '_mayBeUsed',true)\n          clearDesignErrorOfNode(OutNode)        // may be changed later, though\n        })\n      }\n\n    /**** existingInNodes ****/\n\n      function existingInNodes ():NR_Node[] {\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (Node.type === 'reusable-in') { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** InNodesWithNameInWorkspace ****/\n\n      function InNodesWithNameInWorkspace (\n        Name:string, Workspace:NR_Workspace\n      ):NR_Node[] {\n        Name = Name.toLowerCase()\n\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (\n              (Node.type === 'reusable-in')           &&\n              (WorkspaceWithId[Node.z] === Workspace) &&\n              ((Node.name || '').trim().toLowerCase() === Name)\n            ) { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** validateAllReusableInNodes ****/\n\n      function validateAllReusableInNodes () {\n        let InNodes:NR_Node[] = existingInNodes()\n        InNodes.forEach((InNode:NR_Node) => {\n          if (WorkspaceWithId[InNode.z] == null) return setDesignErrorOfNode(\n            InNode, 'do not begin reusable flows within subflows'\n          )\n\n          let NodeName = (InNode.name || '').trim().toLowerCase()\n          if (NodeName === '') return setDesignErrorOfNode(\n            InNode, 'no flow name given'\n          )\n\n          let InNodesWithThisName = InNodesWithNameInWorkspace(NodeName,WorkspaceWithId[InNode.z])\n          if (InNodesWithThisName.length > 1) return setDesignErrorOfNode(\n            InNode, 'multiple \"reusable-in\" nodes with this name'\n          )\n\n          let wiredOutNodes = allDownstreamNodesOf(InNode).filter(\n            (Node:NR_Node) => (Node.type === 'reusable-out')\n          )  // don't worry about OutNodes with multiple connected InNodes right now\n          if (wiredOutNodes.length === 0) return setDesignErrorOfNode(\n            InNode, 'no connected \"reusable-out\" node'\n          )\n\n          clearDesignErrorOfNode(InNode)\n\n        /**** determine number of outputs ****/\n\n          if (wiredOutNodes.length === 1) {\n            let OutNode = wiredOutNodes[0]\n\n            let Index = OutNode._Index\n            if (Index >= 1) {\n              setDesignErrorOfNode(OutNode, 'invalid output position')\n            }\n\n            tweak(InNode,'outputs',1)\n          } else {\n            let OutLabelSet = Object.create(null)\n\n            let sortedOutNodes = new Array(wiredOutNodes.length)\n              wiredOutNodes.forEach((OutNode:NR_Node) => {\n                let Index = OutNode._Index\n                if (Index >= wiredOutNodes.length) {\n                  return setDesignErrorOfNode(OutNode, 'invalid output position')\n                }\n\n                if (sortedOutNodes[Index] == null) { // detect position collisions\n                  sortedOutNodes[Index] = OutNode\n                } else {\n                  setDesignErrorOfNode(sortedOutNodes[Index], 'multiply used output position')\n                  setDesignErrorOfNode(OutNode,               'multiply used output position')\n                  return\n                }\n\n                let OutLabel = (OutNode.name || '').trim().toLowerCase()\n                if (OutLabel !== '') {                // detect label collisions\n                  if (OutLabelSet[OutLabel] == null) {\n                    OutLabelSet[OutLabel] = OutNode\n                  } else {\n                    setDesignErrorOfNode(sortedOutNodes[Index], 'multiply used output label')\n                    setDesignErrorOfNode(OutNode,               'multiply used output label')\n                    return\n                  }\n                }\n              })\n            tweak(InNode,'outputs',sortedOutNodes.length)\n          }\n\n        /**** determine node usability ****/\n\n          wiredOutNodes.forEach(\n            (OutNode:NR_Node) => tweak(OutNode, '_mayBeUsed', OutNode._DesignError == null)\n          )\n\n          tweak(InNode, '_mayBeUsed',(InNode._DesignError == null) && wiredOutNodes.reduce(\n            (Result:boolean,OutNode:NR_Node) => (Result && OutNode._mayBeUsed), true\n          ))\n\n          if (InNode._mayBeUsed) {\n            clearDesignErrorOfNode(InNode)\n          } else {\n            if (InNode._DesignError == null) {\n              setDesignErrorOfNode(InNode, 'error in \"reusable-out\" node')\n            }\n          }\n        })\n      }\n\n    /**** existingUseNodes ****/\n\n      function existingUseNodes ():NR_Node[] {\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (Node.type === 'reusable') { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** WorkspacesWithLabel ****/\n\n      function WorkspacesWithLabel (Label:string):NR_Workspace[] {\n        Label = Label.trim().toLowerCase()\n\n        let Result:NR_Workspace[] = []\n          Workspaces.forEach((Workspace:NR_Workspace) => {\n            if (Workspace.label.trim().toLowerCase() === Label) {\n              Result.push(Workspace)\n            }\n          })\n        return Result\n      }\n\n    /**** validateAllReusableNodes ****/\n\n      function validateAllReusableNodes () {\n        let UseNodes:NR_Node[] = existingUseNodes()\n        UseNodes.forEach((UseNode:NR_Node) => {\n          if (WorkspaceWithId[UseNode.z] == null) return setDesignErrorOfNode(\n            UseNode, 'do not invoke reusable flows from within subflows'\n          )\n\n          let TargetSpec = (UseNode.target || '').trim().toLowerCase()\n          if (TargetSpec === '') return setDesignErrorOfNode(\n            UseNode, 'missing target specification'\n          )\n\n          let WorkspaceLabel, InNodeName\n          if (TargetSpec.indexOf(':') < 0) {\n            WorkspaceLabel = ''; InNodeName = TargetSpec\n          } else {\n            WorkspaceLabel = TargetSpec.replace(/\\s*:.*$/,'')\n            InNodeName     = TargetSpec.replace(/^[^:]*:\\s*/,'')\n          }\n\n          let Workspace = WorkspaceWithId[UseNode.z]\n          if (WorkspaceLabel !== '') {\n            let Workspaces = WorkspacesWithLabel(WorkspaceLabel)\n            switch (Workspaces.length) {\n              case 0:  return setDesignErrorOfNode(UseNode, 'no such target workspace')\n              case 1:  Workspace = Workspaces[0]; break\n              default: return setDesignErrorOfNode(UseNode, 'multiple target workspaces')\n            }\n          }\n\n          if (InNodeName === '') return setDesignErrorOfNode(\n            UseNode, 'missing target flow name'\n          )\n\n          let InNodes = InNodesWithNameInWorkspace(InNodeName,Workspace).filter(\n            (InNode) => (InNode.scope === 'global') || (InNode.z === UseNode.z)\n          )\n\n          switch (InNodes.length) {\n            case 0:  return setDesignErrorOfNode(UseNode, 'no such target flow')\n            case 1:  tweak(UseNode, '_TargetNode',InNodes[0]); break\n            default: return setDesignErrorOfNode(UseNode, 'multiple target flows')\n          }\n\n          tweak(UseNode,'_mayBeUsed',UseNode._TargetNode._mayBeUsed)\n          if (UseNode._mayBeUsed) {\n            clearDesignErrorOfNode(UseNode)\n          } else {\n            setDesignErrorOfNode(UseNode, 'error in target flow')\n          }\n        })\n      }\n\n    /**** collect workspaces ****/\n\n      let Workspaces:NR_Workspace = []\n      let WorkspaceWithId         = Object.create(null)\n      RED.nodes.eachNode((Node:NR_Node) => {\n        if (Node.type === 'tab') {\n          WorkspaceWithId[Node.id] = Node\n          Workspaces.push(Node)\n        }\n      })\n\n      try {\n        validateAllReusableOutNodes()\n        validateAllReusableInNodes()\n        validateAllReusableNodes()\n      } catch (Signal) {     // Node-RED swallows exceptions and breaks silently\n        console.error(Signal)\n      }\n    }\n\n    RED.events.on('flows:started', validateReusableFlows)\n  }\n"],"names":["RED","nodes","registerType","config","createNode","this","thisNode","name","scope","_mayBeUsed","_DesignError","undefined","on","msg","send","done","error","apply","arguments","InvocationEvent","id","InvocationEventListener","receive","events","TweakEvent","TweakListener","Tweak","Key","Value","status","fill","shape","text","removeListener","position","_Index","Internals","_reusableFlows","callingNodeId","Stack","pop","Mode","Index","emit","Signal","target","outputs","_TargetNode","push","Math","round","MsgList","Array","ReturnEvent","ReturnEventListener","NodeSet","Object","create","eachNode","Node","UpstreamWiresOfNode","tweak","setDesignErrorOfNode","DesignError","clearDesignErrorOfNode","InNodesWithNameInWorkspace","Name","Workspace","toLowerCase","Result","type","WorkspaceWithId","z","trim","wires","flat","forEach","DownstreamNodeId","Workspaces","OutNode","wiredInNodes","connectedNodeSet","registerUpstreamNodesOf","connectedNodeId","connectedNode","NodeId","allUpstreamNodesOf","filter","length","parseInt","isNaN","InNode","NodeName","wiredOutNodes","registerDownstreamNodesOf","allDownstreamNodesOf","OutLabelSet_1","sortedOutNodes_1","OutLabel","reduce","validateAllReusableInNodes","UseNode","WorkspaceLabel","InNodeName","TargetSpec","indexOf","replace","Workspaces_1","Label","label","WorkspacesWithLabel","InNodes","validateAllReusableNodes","console"],"mappings":"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"}