{"version":3,"file":"reusable-flows.js","sources":["../src/reusable-flows.ts"],"sourcesContent":["/**** some basic type definitions for safety (or for illustration) ****/\n\n  type NR_Node      = any\n  type NR_Workspace = any\n  type NR_Id        = string\n  type NR_Config    = any\n  type NR_Msg = {\n    topic?:string, payload:any, script?:string,\n    _reusableFlows:{ Mode?:'return', Index?:number, Stack:number[] }\n  }\n  type NR_send   = (msg:NR_Msg | NR_Msg[] | NR_Msg[][] | null) => void\n  type NR_done   = (err?:any) => void\n\n/**** actual node definition ****/\n\n  export default function (RED:any):void {\n    let NodeSet:{ [Id:string]:NR_Node }        // will be filled at flow startup\n\n    let InvocationCounter:number                    = 0\n    let InvocationMapper:{ [Index:number]:NR_Node } = Object.create(null)\n\n  /**** resuable-in ****/\n\n    function ReusableIn (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let thisNode:NR_Node = this\n        thisNode.name  = config.name\n        thisNode.scope = config.scope\n\n        thisNode._mayBeUsed   = false                   // set during validation\n        thisNode._DesignError = undefined\n      thisNode.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        if (! thisNode._mayBeUsed) {\n          return (done == null ? thisNode.error : done)(\n            'reusable-in: must not be used due to pending errors'\n          )\n        }\n\n        send = send || function () { thisNode.send.apply(thisNode,arguments) }\n\n        send(msg)\n        if (done) { done() }\n      })\n\n    /**** handle invocations ****/\n\n      const InvocationEvent = 'reusable:' + config.id\n\n      function InvocationEventListener (msg:any):void {\n        thisNode.receive(msg)\n      }\n\n      RED.events.on(InvocationEvent,InvocationEventListener)\n\n    /**** handle \"tweak\" events ****/\n\n      const TweakEvent = 'tweak-' + config.id\n\n      function TweakListener (Tweak:any[]):void {\n        let [ Key,Value ] = Tweak\n        thisNode[Key] = Value\n\n        if (Key === '_DesignError') {\n          if (Value == null) {\n            thisNode.status({})\n          } else {\n            thisNode._mayBeUsed = false\n            thisNode.status({ fill:'red', shape:'dot', text:Value })\n          }\n        }\n      }\n\n      RED.events.on(TweakEvent,TweakListener)\n\n    /**** clean up on close ****/\n\n      thisNode.on('close', () => {\n        RED.events.removeListener(InvocationEvent,InvocationEventListener)\n        RED.events.removeListener(TweakEvent,TweakListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable-in', ReusableIn)\n\n  /**** resuable-out ****/\n\n    function ReusableOut (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n      let thisNode:NR_Node = this\n        thisNode.position = config.position\n\n        thisNode._Index       = undefined\n        thisNode._mayBeUsed   = false     // set during \"reusable-in\" validation\n        thisNode._DesignError = undefined\n      thisNode.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        if (! thisNode._mayBeUsed) {\n          return (done == null ? thisNode.error : done)(\n            'reusable-out: must not be used due to pending errors'\n          )\n        }\n\n        try {\n          let Internals = msg._reusableFlows\n\n          let InvocationIndex = Internals.Stack.pop()\n          if (InvocationIndex == null) {\n            throw 'reusable-out: no invocation to return to found'\n          }\n\n          let callingNodeId = InvocationMapper[InvocationIndex]\n            delete InvocationMapper[InvocationIndex] // don't reuse this return!\n          if (typeof callingNodeId !== 'string') {\n            throw 'reusable-out: broken invocation ' +\n              '(did you try to return several times from the same invocation?)'\n          }\n\n          let callingNode = NodeSet[callingNodeId]\n          if (callingNode == null) {\n            throw 'reusable-out: no \"reusable\" node to return to found'\n          } else {\n            Internals.Mode  = 'return'\n            Internals.Index = thisNode._Index\n            RED.events.emit('reusable:' + callingNodeId, msg)\n            if (done) { done() }\n          }\n        } catch (Signal) {\n          return (done == null ? thisNode.error : done)(\n            typeof Signal === 'string'\n            ? Signal\n            : 'reusable-out: broken \"msg\" (broken or missing internals)'\n          )\n        }\n      })\n\n    /**** handle \"tweak\" events ****/\n\n      const TweakEvent = 'tweak-' + config.id\n\n      function TweakListener (Tweak:any[]):void {\n        let [ Key,Value ] = Tweak\n        thisNode[Key] = Value\n\n        if (Key === '_DesignError') {\n          if (Value == null) {\n            thisNode.status({})\n          } else {\n            thisNode._mayBeUsed = false\n            thisNode.status({ fill:'red', shape:'dot', text:Value })\n          }\n        }\n      }\n\n      RED.events.on(TweakEvent,TweakListener)\n\n    /**** clean up on close ****/\n\n      thisNode.on('close', () => {\n        RED.events.removeListener(TweakEvent,TweakListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable-out', ReusableOut)\n\n  /**** reusable - the calling node ****/\n\n    function Reusable (this:any, config:NR_Config):void {\n      RED.nodes.createNode(this,config)\n\n    /**** handle calls to the associated flow ****/\n\n      const thisNode:NR_Node = this\n        thisNode.target  = config.target\n        thisNode.outputs = config.outputs\n\n        thisNode._TargetNode  = undefined\n        thisNode._mayBeUsed   = false                   // set during validation\n        thisNode._DesignError = undefined\n      thisNode.on('input', function (msg:NR_Msg, send?:NR_send, done?:NR_done) {\n        if (! thisNode._mayBeUsed) {\n          return (done == null ? thisNode.error : done)(\n            'reusable: must not be used due to pending errors'\n          )\n        }\n\n        send = send || function () { thisNode.send.apply(thisNode,arguments) }\n\n        let Internals = msg._reusableFlows\n        if (Internals == null) {\n          Internals = msg._reusableFlows = { Stack:[] }\n        }\n\n        switch (Internals.Mode) {\n          case undefined:                                              // 'call'\n            InvocationCounter += 1\n            InvocationMapper[InvocationCounter] = config.id\n\n            Internals.Stack.push(InvocationCounter)\n            RED.events.emit('reusable:' + thisNode._TargetNode.id, msg)\n            break\n          case 'return':                                             // 'return'\n            let Index = Internals.Index\n            delete Internals.Mode; delete Internals.Index\n\n            switch (true) {\n              case (thisNode.outputs === 1):\n                send(msg)\n                break\n              case (Index === 0):\n                send([msg])\n                break\n              case (typeof Index !== 'number'):\n// @ts-ignore \"Index\" is now known to be a number\n              case (Math.round(Index) !== Index): // also handles NaN\n// @ts-ignore \"Index\" is now known to be an integer\n              case (Index < 0):\n// @ts-ignore \"Index\" is still known to be an integer\n              case (Index >= thisNode.outputs):\n                return (done == null ? thisNode.error : done)(\n                  'reusable: broken \"msg\" (invalid \"Index\")'\n                )\n              default:\n                let MsgList = new Array(thisNode.outputs)\n// @ts-ignore \"Index\" is known to be an integer\n                  MsgList[Index] = msg\n                send(MsgList)\n            }\n            if (done) { done() }\n            break\n          default:                                                 // broken msg\n            return (done == null ? thisNode.error : done)(\n              'reusable: broken \"msg\" (missing \"Mode\")'\n            )\n        }\n      })\n\n    /**** handle returns from the called flow ****/\n\n      const ReturnEvent = 'reusable:' + config.id\n\n      function ReturnEventListener (msg:any):void {\n        thisNode.receive(msg)\n      }\n\n      RED.events.on(ReturnEvent,ReturnEventListener)\n\n    /**** handle \"tweak\" events ****/\n\n      const TweakEvent = 'tweak-' + config.id\n\n      function TweakListener (Tweak:any[]):void {\n        let [ Key,Value ] = Tweak\n        thisNode[Key] = Value\n\n        if (Key === '_DesignError') {\n          if (Value == null) {\n            thisNode.status({})\n          } else {\n            thisNode._mayBeUsed = false\n            thisNode.status({ fill:'red', shape:'dot', text:Value })\n          }\n        }\n      }\n\n      RED.events.on(TweakEvent,TweakListener)\n\n    /**** clean up on close ****/\n\n      thisNode.on('close', () => {\n        RED.events.removeListener(ReturnEvent,ReturnEventListener)\n        RED.events.removeListener(TweakEvent,TweakListener)\n      })\n    }\n\n    RED.nodes.registerType('reusable', Reusable)\n\n  /**** validateReusableFlows ****/\n\n    function validateReusableFlows () {\n      NodeSet = Object.create(null)      // collect all nodes for a quick lookup\n      RED.nodes.eachNode((Node:NR_Node) => {\n        NodeSet[Node.id] = Node\n      })\n\n      let UpstreamWiresOfNode = Object.create(null)    // to find upstream nodes\n      RED.nodes.eachNode((Node:NR_Node) => {\n        let DownstreamWires = (Node.wires || []).flat()\n        DownstreamWires.forEach((DownstreamNodeId:NR_Id) => {\n          if (DownstreamNodeId in UpstreamWiresOfNode) {\n            UpstreamWiresOfNode[DownstreamNodeId].push(Node.id)\n          } else {\n            UpstreamWiresOfNode[DownstreamNodeId] = [Node.id]\n          }\n        })\n      })\n\n    /**** tweak ****/\n\n      function tweak (Node:NR_Node, Key:string, Value:any):void {\n        Node[Key] = Value\n        if ((Key === '_DesignError') && (Value != null)) {\n          Node._mayBeUsed = false\n        }\n\n        RED.events.emit('tweak-' + Node.id, [Key,Value])\n      }\n\n    /**** setDesignErrorOfNode ****/\n\n      function setDesignErrorOfNode (Node:NR_Node, DesignError:string):void {\n        tweak(Node, '_DesignError',DesignError)\n      }\n\n    /**** clearDesignErrorOfNode ****/\n\n      function clearDesignErrorOfNode (Node:NR_Node):void {\n        tweak(Node, '_DesignError',undefined)\n      }\n\n  /**** allUpstreamNodesOf - still to be implemented ****/\n\n    function allUpstreamNodesOf (Node:NR_Node):NR_Node[] {\n      let connectedNodeSet = Object.create(null)\n        connectedNodeSet[Node.id] = Node\n\n        function registerUpstreamNodesOf (Node:NR_Node):void {\n          let UpstreamWires = UpstreamWiresOfNode[Node.id] || []\n          UpstreamWires.forEach((connectedNodeId:NR_Id) => {\n            if (! (connectedNodeId in connectedNodeSet)) {\n              let connectedNode = NodeSet[connectedNodeId]\n              connectedNodeSet[connectedNodeId] = connectedNode\n              registerUpstreamNodesOf(connectedNode)\n            }\n          })\n        }\n        registerUpstreamNodesOf(Node)\n      let Result = []\n        delete connectedNodeSet[Node.id]\n        for (let NodeId in connectedNodeSet) {\n          Result.push(connectedNodeSet[NodeId])\n        }\n      return Result\n    }\n\n  /**** allDownstreamNodesOf ****/\n\n    function allDownstreamNodesOf (Node:NR_Node):NR_Node[] {\n      let connectedNodeSet = Object.create(null)\n        connectedNodeSet[Node.id] = Node\n\n        function registerDownstreamNodesOf (Node:NR_Node):void {\n          let DownstreamWires = Node.wires.flat()\n          DownstreamWires.forEach((connectedNodeId:NR_Id) => {\n            if (! (connectedNodeId in connectedNodeSet)) {\n              let connectedNode = NodeSet[connectedNodeId]\n              connectedNodeSet[connectedNodeId] = connectedNode\n              registerDownstreamNodesOf(connectedNode)\n            }\n          })\n        }\n        registerDownstreamNodesOf(Node)\n      let Result = []\n        delete connectedNodeSet[Node.id]\n        for (let NodeId in connectedNodeSet) {\n          Result.push(connectedNodeSet[NodeId])\n        }\n      return Result\n    }\n\n    /**** existingOutNodes ****/\n\n      function existingOutNodes ():NR_Node[] {\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (Node.type === 'reusable-out') { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** validateAllReusableOutNodes ****/\n\n      function validateAllReusableOutNodes () {\n        let OutNodes:NR_Node[] = existingOutNodes()\n        OutNodes.forEach((OutNode) => {\n          if (WorkspaceWithId[OutNode.z] == null) return setDesignErrorOfNode(\n            OutNode, 'do not end reusable flows within subflows'\n          )\n\n          let wiredInNodes = allUpstreamNodesOf(OutNode).filter(\n            (Node:NR_Node) => (Node.type === 'reusable-in')\n          )\n          if (wiredInNodes.length === 0) return setDesignErrorOfNode(\n            OutNode, 'no connected \"reusable-in\" node'\n          )\n\n          if (wiredInNodes.length > 1) return setDesignErrorOfNode(\n            OutNode, 'multiple connected \"reusable-in\" nodes'\n          )\n\n          let Index = parseInt(OutNode.position,10) - 1               // 0-based\n          if (isNaN(Index)) {\n            return setDesignErrorOfNode(OutNode,'invalid \"position\"')\n          } else {\n            tweak(OutNode, '_Index',Index)\n          }\n\n          tweak(OutNode, '_mayBeUsed',true)\n          clearDesignErrorOfNode(OutNode)        // may be changed later, though\n        })\n      }\n\n    /**** existingInNodes ****/\n\n      function existingInNodes ():NR_Node[] {\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (Node.type === 'reusable-in') { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** InNodesWithNameInWorkspace ****/\n\n      function InNodesWithNameInWorkspace (\n        Name:string, Workspace:NR_Workspace\n      ):NR_Node[] {\n        Name = Name.toLowerCase()\n\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (\n              (Node.type === 'reusable-in')           &&\n              (WorkspaceWithId[Node.z] === Workspace) &&\n              ((Node.name || '').trim().toLowerCase() === Name)\n            ) { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** validateAllReusableInNodes ****/\n\n      function validateAllReusableInNodes () {\n        let InNodes:NR_Node[] = existingInNodes()\n        InNodes.forEach((InNode:NR_Node) => {\n          if (WorkspaceWithId[InNode.z] == null) return setDesignErrorOfNode(\n            InNode, 'do not begin reusable flows within subflows'\n          )\n\n          let NodeName = (InNode.name || '').trim().toLowerCase()\n          if (NodeName === '') return setDesignErrorOfNode(\n            InNode, 'no flow name given'\n          )\n\n          let InNodesWithThisName = InNodesWithNameInWorkspace(NodeName,WorkspaceWithId[InNode.z])\n          if (InNodesWithThisName.length > 1) return setDesignErrorOfNode(\n            InNode, 'multiple \"reusable-in\" nodes with this name'\n          )\n\n          let wiredOutNodes = allDownstreamNodesOf(InNode).filter(\n            (Node:NR_Node) => (Node.type === 'reusable-out')\n          )  // don't worry about OutNodes with multiple connected InNodes right now\n          if (wiredOutNodes.length === 0) return setDesignErrorOfNode(\n            InNode, 'no connected \"reusable-out\" node'\n          )\n\n          clearDesignErrorOfNode(InNode)\n\n        /**** determine number of outputs ****/\n\n          if (wiredOutNodes.length === 1) {\n            let OutNode = wiredOutNodes[0]\n\n            let Index = OutNode._Index\n            if (Index >= 1) {\n              setDesignErrorOfNode(OutNode, 'invalid output position')\n            }\n\n            tweak(InNode,'outputs',1)\n          } else {\n            let OutLabelSet = Object.create(null)\n\n            let sortedOutNodes = new Array(wiredOutNodes.length)\n              wiredOutNodes.forEach((OutNode:NR_Node) => {\n                let Index = OutNode._Index\n                if (Index >= wiredOutNodes.length) {\n                  return setDesignErrorOfNode(OutNode, 'invalid output position')\n                }\n\n                if (sortedOutNodes[Index] == null) { // detect position collisions\n                  sortedOutNodes[Index] = OutNode\n                } else {\n                  setDesignErrorOfNode(sortedOutNodes[Index], 'multiply used output position')\n                  setDesignErrorOfNode(OutNode,               'multiply used output position')\n                  return\n                }\n\n                let OutLabel = (OutNode.name || '').trim().toLowerCase()\n                if (OutLabel !== '') {                // detect label collisions\n                  if (OutLabelSet[OutLabel] == null) {\n                    OutLabelSet[OutLabel] = OutNode\n                  } else {\n                    setDesignErrorOfNode(sortedOutNodes[Index], 'multiply used output label')\n                    setDesignErrorOfNode(OutNode,               'multiply used output label')\n                    return\n                  }\n                }\n              })\n            tweak(InNode,'outputs',sortedOutNodes.length)\n          }\n\n        /**** determine node usability ****/\n\n          wiredOutNodes.forEach(\n            (OutNode:NR_Node) => tweak(OutNode, '_mayBeUsed', OutNode._DesignError == null)\n          )\n\n          tweak(InNode, '_mayBeUsed',(InNode._DesignError == null) && wiredOutNodes.reduce(\n            (Result:boolean,OutNode:NR_Node) => (Result && OutNode._mayBeUsed), true\n          ))\n\n          if (InNode._mayBeUsed) {\n            clearDesignErrorOfNode(InNode)\n          } else {\n            if (InNode._DesignError == null) {\n              setDesignErrorOfNode(InNode, 'error in \"reusable-out\" node')\n            }\n          }\n        })\n      }\n\n    /**** existingUseNodes ****/\n\n      function existingUseNodes ():NR_Node[] {\n        let Result:NR_Node[] = []\n          RED.nodes.eachNode((Node:NR_Node) => {\n            if (Node.type === 'reusable') { Result.push(Node) }\n          })\n        return Result\n      }\n\n    /**** WorkspacesWithLabel ****/\n\n      function WorkspacesWithLabel (Label:string):NR_Workspace[] {\n        Label = Label.trim().toLowerCase()\n\n        let Result:NR_Workspace[] = []\n          Workspaces.forEach((Workspace:NR_Workspace) => {\n            if (Workspace.label.trim().toLowerCase() === Label) {\n              Result.push(Workspace)\n            }\n          })\n        return Result\n      }\n\n    /**** validateAllReusableNodes ****/\n\n      function validateAllReusableNodes () {\n        let UseNodes:NR_Node[] = existingUseNodes()\n        UseNodes.forEach((UseNode:NR_Node) => {\n          if (WorkspaceWithId[UseNode.z] == null) return setDesignErrorOfNode(\n            UseNode, 'do not invoke reusable flows from within subflows'\n          )\n\n          let TargetSpec = (UseNode.target || '').trim().toLowerCase()\n          if (TargetSpec === '') return setDesignErrorOfNode(\n            UseNode, 'missing target specification'\n          )\n\n          let WorkspaceLabel, InNodeName\n          if (TargetSpec.indexOf(':') < 0) {\n            WorkspaceLabel = ''; InNodeName = TargetSpec\n          } else {\n            WorkspaceLabel = TargetSpec.replace(/\\s*:.*$/,'')\n            InNodeName     = TargetSpec.replace(/^[^:]*:\\s*/,'')\n          }\n\n          let Workspace = WorkspaceWithId[UseNode.z]\n          if (WorkspaceLabel !== '') {\n            let Workspaces = WorkspacesWithLabel(WorkspaceLabel)\n            switch (Workspaces.length) {\n              case 0:  return setDesignErrorOfNode(UseNode, 'no such target workspace')\n              case 1:  Workspace = Workspaces[0]; break\n              default: return setDesignErrorOfNode(UseNode, 'multiple target workspaces')\n            }\n          }\n\n          if (InNodeName === '') return setDesignErrorOfNode(\n            UseNode, 'missing target flow name'\n          )\n\n          let InNodes = InNodesWithNameInWorkspace(InNodeName,Workspace).filter(\n            (InNode) => (InNode.scope === 'global') || (InNode.z === UseNode.z)\n          )\n\n          switch (InNodes.length) {\n            case 0:  return setDesignErrorOfNode(UseNode, 'no such target flow')\n            case 1:  tweak(UseNode, '_TargetNode',InNodes[0]); break\n            default: return setDesignErrorOfNode(UseNode, 'multiple target flows')\n          }\n\n          tweak(UseNode,'_mayBeUsed',UseNode._TargetNode._mayBeUsed)\n          if (UseNode._mayBeUsed) {\n            clearDesignErrorOfNode(UseNode)\n          } else {\n            setDesignErrorOfNode(UseNode, 'error in target flow')\n          }\n        })\n      }\n\n    /**** collect workspaces ****/\n\n      let Workspaces:NR_Workspace = []\n      let WorkspaceWithId         = Object.create(null)\n      RED.nodes.eachNode((Node:NR_Node) => {\n        if (Node.type === 'tab') {\n          WorkspaceWithId[Node.id] = Node\n          Workspaces.push(Node)\n        }\n      })\n\n      try {\n        validateAllReusableOutNodes()\n        validateAllReusableInNodes()\n        validateAllReusableNodes()\n      } catch (Signal) {     // Node-RED swallows exceptions and breaks silently\n        console.error(Signal)\n      }\n    }\n\n    RED.events.on('flows:started', validateReusableFlows)\n  }\n"],"names":["RED","NodeSet","InvocationCounter","InvocationMapper","Object","create","nodes","registerType","config","createNode","this","thisNode","name","scope","_mayBeUsed","_DesignError","undefined","on","msg","send","done","error","apply","arguments","InvocationEvent","id","InvocationEventListener","receive","events","TweakEvent","TweakListener","Tweak","Key","Value","status","fill","shape","text","removeListener","position","_Index","Internals","_reusableFlows","InvocationIndex","Stack","pop","callingNodeId","Mode","Index","emit","Signal","target","outputs","_TargetNode","push","Math","round","MsgList","Array","ReturnEvent","ReturnEventListener","eachNode","Node","UpstreamWiresOfNode","tweak","setDesignErrorOfNode","DesignError","clearDesignErrorOfNode","InNodesWithNameInWorkspace","Name","Workspace","toLowerCase","Result","type","WorkspaceWithId","z","trim","wires","flat","forEach","DownstreamNodeId","Workspaces","OutNode","wiredInNodes","connectedNodeSet","registerUpstreamNodesOf","connectedNodeId","connectedNode","NodeId","allUpstreamNodesOf","filter","length","parseInt","isNaN","InNode","NodeName","wiredOutNodes","registerDownstreamNodesOf","allDownstreamNodesOf","OutLabelSet_1","sortedOutNodes_1","OutLabel","reduce","validateAllReusableInNodes","UseNode","WorkspaceLabel","InNodeName","TargetSpec","indexOf","replace","Workspaces_1","Label","label","WorkspacesWithLabel","InNodes","validateAllReusableNodes","console"],"mappings":"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"}